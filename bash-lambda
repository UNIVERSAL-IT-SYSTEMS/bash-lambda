#!/bin/bash
# Bash-lambda

# Source this file to create a function allocation space and enable first-class
# functions in the shell. The heap will be deleted automatically when the shell
# exits. See https://github.com/spencertipping/bash-lambda for documentation.

# Bash-lambda disk-based heap

# We need 128 bits of entropy for the heap directory name. This gives us
# guarantees about the soundness of conservative garbage collection ... for the
# rest of the story, see src/gc.

# 128 bits total / 15 bits per random number = 9 numbers
bash_lambda_genkey() { declare i
                       for (( i = 0; i < 9; i += 1 )); do
                         printf '%04x' $RANDOM; done; }

# Allow the user to override the heap location if they want to. However, this
# may compromise the effectiveness of conservative GC.
export BASH_LAMBDA_KEY=$(bash_lambda_genkey)
export BASH_LAMBDA_HEAP=${BASH_LAMBDA_HEAP:-/tmp/blheap-$$-$BASH_LAMBDA_KEY}

mkdir -p "$BASH_LAMBDA_HEAP" || return 1
ln -s "$BASH_LAMBDA_HEAP" "$BASH_LAMBDA_HEAP/.weak-references"
date +%s > "$BASH_LAMBDA_HEAP/.last-gc"
bash_lambda_nuke_heap() { [[ "${BASH_LAMBDA_HEAP:0:5}" == "/tmp/" ]] &&
                          rm -rf "$BASH_LAMBDA_HEAP"; }
trap bash_lambda_nuke_heap EXIT
export PATH="$PATH:$BASH_LAMBDA_HEAP"

# Heap allocation
bash_lambda_gensym() { mktemp "$BASH_LAMBDA_HEAP/${1:-gensym}_XXXXXXXXXXXXXX"; }
bash_lambda_gendir() { mktemp -d "$BASH_LAMBDA_HEAP/${1:-gensym}_XXXXXXXXXXX"; }

bash_lambda_sym() { bash_lambda_gc_guard "$(bash_lambda_gensym)"; }
bash_lambda_dir() { bash_lambda_gc_guard "$(bash_lambda_gendir)"; }

bash_lambda_gc_guard() {
  declare file=$1

  # If garbage collection is in-progress, mark the object to prevent it from
  # being collected this time around. We don't mark it as having been visited,
  # however; doing that would cause anything it makes live to be collected
  # erroneously.
  touch "$BASH_LAMBDA_HEAP/.gc-marked-set/${file##*/}" >& /dev/null
  echo "$file"; }

bash_lambda_cons() {
  if [[ $1 == '-n' ]]; then declare file=$BASH_LAMBDA_HEAP/$2
  else                      declare file="$(bash_lambda_gensym $1)"; fi

  cat > $(bash_lambda_gc_guard "$file") &&      # Take everything from stdin
    chmod u+x "$file"                   &&      # All conses are executable
    echo "$file"; }

# Bash-lambda reference functions

# A weak reference is a path that resolves the same way as a regular path, but
# that isn't followed by the garbage collector. src/heap sets up a symlink for
# this purpose.
bash_lambda_weak_ref() {
  echo "$BASH_LAMBDA_HEAP/.weak-references/${1##$BASH_LAMBDA_HEAP/}"; }

bash_lambda_ref_snapshot() {
  tar -czP $(bash_lambda_ref_closure "$1") | bash_lambda_cons shapshot; }

bash_lambda_ref_intern() { cat ${1:--} | tar -xzP; }

bash_lambda_ref_closure() {
  declare visited=$(bash_lambda_dir) object=$1
  bash_lambda_ref_visit "$visited" "$object"
  ls -d "$visited"/* | (declare x; while read x; do
    echo "$BASH_LAMBDA_HEAP/${x##$visited/}"; done); }

bash_lambda_ref_type() { declare base=${1##*/}; echo "${base%%_*}"; }

bash_lambda_ref_visit() {
  # The ref in question must be an object that exists in the heap. We expect it
  # to be a full pathname, though the object itself should be a direct child of
  # the heap directory.
  declare directory="$1" ref="$2"
  declare ref_name="${ref#$BASH_LAMBDA_HEAP/}"

  # Is this a fictitious reference or something that belongs to the GC?
  [[ -L "$ref" || "$ref_name" == ".gc-marked-set"
               || "$ref_name" == ".gc-visited-set" ]] && return 0

  # No need to mark an object in a subdirectory. It isn't a direct child of the
  # heap, so its storage is already being managed by the directory it belongs
  # to.
  if [[ ! ("$ref_name" =~ /) ]]; then
    # Have we already visited this object? If so, no need to revisit it.
    [[ -e "$directory/$ref_name" ]] && return 0

    # Otherwise, mark the object and everything it points to.
    touch "$directory/$ref_name"; fi

  # Make sure any recursive calls happen inside a subshell. Otherwise we'll
  # corrupt local variables.
  if [[ -d "$ref" ]]; then
    ls -d "$ref"/* | (declare x; while read x; do
                        bash_lambda_ref_visit "$directory" "$x"; done)
  else
    # Search for other references in the child.
    bash_lambda_ref_children < "$ref" | (declare x
      while read x; do bash_lambda_ref_visit "$directory" "$x"; done); fi; }

bash_lambda_ref_children() {
  # Locate occurrences of the heap directory. This name contains 128 bits of
  # pseudorandom entropy, so we are unlikely to see it spuriously referenced.
  # If we observe a path that exists, then we consider that to be a reference
  # for GC purposes.
  #
  # Note that we don't consider FIFOs to be references. These are used by
  # futures for locking, and if we tried to read from them we could stop the GC
  # process.

  egrep -o "$BASH_LAMBDA_HEAP/[^ [:space:]/\)\}\"']+" | (declare ref
    while read ref; do [[ -e "$ref" && ! -p "$ref" ]] && echo "$ref"; done); }

# Bash-lambda concurrent mark-sweep garbage collector

# BASH_LAMBDA_GC_SECONDS=0 will disable automatic GC
# BASH_LAMBDA_GC_CONCURRENT=0 will cause GC to be synchronous
export BASH_LAMBDA_GC_SECONDS=${BASH_LAMBDA_GC_SECONDS:-30}
export BASH_LAMBDA_GC_CONCURRENT=${BASH_LAMBDA_GC_CONCURRENT:-1}

mkdir -p "$BASH_LAMBDA_HEAP"/.gc-permanent

# Can we see this unexported variable from the garbage collector? If not, then
# we don't have access to the full root set. If you unset this, GC will refuse
# to run. We need this to be a weak ref so the exported variable doesn't show
# up in the root set by itself. These two variables should be identical modulo
# path.
BASH_LAMBDA_GC_CANARY=$(bash_lambda_cons < /dev/null)
export BASH_LAMBDA_GC_KEY=$(bash_lambda_weak_ref $BASH_LAMBDA_GC_CANARY)

# This function can be run asynchronously: bash_lambda_gc &. See
# bash_lambda_auto_gc for an example. It knows which heap to run on, and it
# echoes information about the number of objects and bytes reclaimed.
bash_lambda_gc() {
  # Avert disaster: never GC a heap unless it is in /tmp.
  if [[ "${BASH_LAMBDA_HEAP:0:5}" != "/tmp/" ]]; then
    echo 'bash_lambda_gc refuses to run because $BASH_LAMBDA_HEAP is set to'
    echo 'a directory outside of /tmp/. If you really want to do this, you'
    echo 'should do something like /tmp/../wherever.'
    return 2; fi

  # Try to acquire the GC lock. If we can't, another GC is probably running; so
  # we exit immediately since GC is (ideally) idempotent.
  mkdir "$BASH_LAMBDA_HEAP"/.gc-visited-set || return 1
  mkdir -p "$BASH_LAMBDA_HEAP"/.gc-marked-set

  # We have the lock. At this point the heap allocator will mark any new
  # objects that are created, so we can use the root set that exists right now
  # and start marking objects referenced by that root set.
  bash_lambda_gc_roots | bash_lambda_ref_children | (declare x; while read x; do
    bash_lambda_ref_visit "$BASH_LAMBDA_HEAP/.gc-visited-set" "$x"; done)

  # We should mark the canary. If we haven't done this, then something is wrong
  # with the root-set computation.
  if [[ ! -e "$BASH_LAMBDA_HEAP/.gc-visited-set/${BASH_LAMBDA_GC_KEY##*/}" ]]
  then
    echo 'bash_lambda_gc cannot see the full root set. You should make sure'
    echo 'it is being run as a function, not as an indirect script; try using'
    echo 'bash_lambda_gc instead of just gc.'
    rm -r "$BASH_LAMBDA_HEAP/".gc-{visited,marked}-set
    return 1; fi

  # Now nuke anything that isn't either marked or permanent.
  ls -d "$BASH_LAMBDA_HEAP"/* | (
    declare ref reclaimed=() reclaimed_size=0
    while read ref; do
      if [[ ! -e "$BASH_LAMBDA_HEAP/.gc-marked-set/${ref##*/}" &&
            ! -e "$BASH_LAMBDA_HEAP/.gc-visited-set/${ref##*/}" &&
            ! -e "$BASH_LAMBDA_HEAP/.gc-permanent/${ref##*/}" ]]; then
        reclaimed+=("$ref")
        reclaimed_size=$((reclaimed_size + $(du -sb "$ref" | cut -f 1)))
        rm -rf "$ref"; fi; done
    echo "${#reclaimed[@]} $reclaimed_size")

  # We are now done. Remove the marked-set directory and echo some stats about
  # the stuff we collected.
  rm -rf "$BASH_LAMBDA_HEAP/".gc-{marked,visited}-set; }

bash_lambda_auto_gc() {
  # Trigger a concurrent GC if it's been more than some number of seconds since
  # the last one. This turns out to be one of the few constant-time ways we can
  # do this safely.
  if (( $BASH_LAMBDA_GC_SECONDS &&
        $(date +%s) - $(<"$BASH_LAMBDA_HEAP/.last-gc") >
          $BASH_LAMBDA_GC_SECONDS )); then
    date +%s > "$BASH_LAMBDA_HEAP/.last-gc"

    # NOTE: Running GC concurrently is experimental and is known to have some
    # problems unless done carefully. See comments in bash_lambda_gc for
    # details.
    if (( $BASH_LAMBDA_GC_CONCURRENT )); then
      (bash_lambda_gc --concurrent >> "$BASH_LAMBDA_HEAP/.gc-log" &)
    else
      bash_lambda_gc >> "$BASH_LAMBDA_HEAP/.gc-log"
    fi; fi; }

bash_lambda_heap_stats() {
  printf '%-20s %s\n%-20s %d\n%-20s %d\n' \
    'heap size:' $(du -sh "$BASH_LAMBDA_HEAP" | cut -f 1) \
    'objects:'   $(ls "$BASH_LAMBDA_HEAP" | wc -l) \
    'permanent:' $(ls "$BASH_LAMBDA_HEAP/.gc-permanent" | wc -l); }

bash_lambda_gc_pin()   { touch "$BASH_LAMBDA_HEAP/.gc-permanent/${1##*/}";
                         echo "$1"; }

bash_lambda_gc_unpin() { rm -f "$BASH_LAMBDA_HEAP/.gc-permanent/${1##*/}";
                         echo "$1"; }

bash_lambda_gc_roots() { declare; ps ax; }

# Bash-lambda function and closure allocation

bash_lambda_fn_body() {
  echo '#!/bin/bash'
  declare i
  for (( i = 1; i <= $#; i += 1 )); do
    if (( $i < $# )); then echo "declare -r ${!i}=\$$i"
    else                   echo "${!i}"; fi
  done; }

bash_lambda_fn() {
  # Yup, we're allocating closures by writing to files and returning their
  # names to the callers. This gives you controllable persistence, heap
  # allocation, and the ability to reference the same closures across multiple
  # processes.
  bash_lambda_fn_body "$@" | bash_lambda_cons fn; }

bash_lambda_cons_fn() {
  # Same as bash_lambda_fn, but body is specified from stdin. Useful for
  # multiline functions when used with heredocs.
  (bash_lambda_fn_body "$@" ''; cat -) | bash_lambda_cons fn; }

bash_lambda_defn() { declare name=$1; shift
                     bash_lambda_fn_body "$@" | bash_lambda_cons -n $name; }

# Exports functions into named files in the heap. This allows them to reference
# each other from inside heap-allocated closures. Any exported functions are
# pinned so that they will never be garbage-collected.
bash_lambda_extern() {
  bash_lambda_gc_pin $( (echo "$1_main() {"
                         declare -f "$1" | grep '^  '
                         echo "}"
                         echo "$1_main \"\$@\"") | bash_lambda_cons -n $1); }

bash_lambda_def() { rm -f $BASH_LAMBDA_HEAP/$1
                    ln -s $2 $(bash_lambda_gc_pin $BASH_LAMBDA_HEAP/$1); }

# Bash-lambda functional programming constructs

# $(comp $f $g $h) x = f $(g $(h x))
# $(partial $f x) y  = f x y
bash_lambda_comp() {
  declare i body
  for (( i = $#; i >= 1; i -= 1 )); do
    if (( $i == $# )); then body="\$(${!i} \"\$@\")";
    else                    body="\$(${!i} $body)"; fi
  done
  bash_lambda_fn "echo $body"; }

bash_lambda_partial() {
  bash_lambda_fn "exec $* \"\$@\""; }

# Bash-lambda multimethods

# These work only on fully-named parameters, not on stuff coming from stdin. If
# we can observe the name, then we can extract the type from the beginning of
# the filename. For example:
#
# $ future $f
# /tmp/blheap-xxxx-xxxx/future_xxxxxxxx
# $ ref_type $(future $f)
# future
# $
#
# We then prepend this to the multimethod name to get the specific function
# name:
#
# $ defmulti get
# $ get $(future $f)   -> future_get $(future $f)

bash_lambda_defmulti() {
  declare multi_name=$1
  bash_lambda_defn $1 '$(bash_lambda_ref_type $1)_'$multi_name' "$@"'; }

# Bash-lambda list programming constructs

bash_lambda_list() { declare x
                     for x; do echo "$x"; done | bash_lambda_cons list; }

bash_lambda_nth()  { cat ${2:--} | head -n$(($1 + 1)) | tail -n1; }

bash_lambda_take() { cat ${2:--} | head -n$1; }
bash_lambda_drop() { cat ${2:--} | (declare i
                                    for (( i = 0; i < $1; i += 1 )); do
                                      read x; done; cat -); }

# Here, 'map' works as both map and mapcat since cons and append are the same
# operation. This arises due to the associativity of cons.
bash_lambda_map()    { cat ${2:--} | (declare x
                                      while read x; do $1 "$x"; done); }
bash_lambda_reduce() { declare f="$1" x="$2"
                       cat ${3:--} | (declare y
                                      while read y; do x="$($f "$x" "$y")"; done
                                      echo "$x"); }
bash_lambda_filter() { cat ${2:--} |
                       (declare x; while read x; do
                                     $1 "$x" > /dev/null && echo "$x"; done); }

bash_lambda_reductions() { declare f="$1" x="$2"
                           cat ${3:--} |
                           (declare y
                            while read y; do x="$($f "$x" "$y")"; echo "$x"
                            done); }

# List generators
bash_lambda_iterate() { declare x="$2"
                        echo "$x"; while x="$($1 "$x")"; do echo "$x"; done; }

bash_lambda_repeatedly() { declare i f="$1" n="$2"
                           for (( i = 0; i != ${n:--1}; i += 1 )); do
                             $f || return $?; done; }

# Tests over lists
bash_lambda_some() { cat ${2:--} |
                     (declare x; while read x; do
                       if $1 "$x" > /dev/null; then
                         echo "$x"; return 0; fi; done
                      return 1); }

bash_lambda_every() { cat ${2:--} |
                      (declare x; while read x; do
                        if ! $1 "$x" > /dev/null; then
                          echo "$x"; return 1; fi; done
                       return 0); }

# Bash-lambda futures (asynchronous processes)

# Futures are files consisting of three lines:
# 1. The filename of the output collector
# 2. The filename of the exit code collector
# 3. The filename of the named pipe that will be closed upon completion
#
# We can't use PID-based locking (e.g. via 'wait') because the future might
# belong to a subshell. To fix this, we need to instead allocate a FIFO that
# listeners can read against, and that the background job will close once it is
# finished.

bash_lambda_future() {
  # Construct a future around the given function application. To do this, we
  # run the function in the background and pipe its output to a temporary file.
  # We also record its exit code.

  declare output=$(bash_lambda_cons future_output < /dev/null)
  declare exit_code=$(bash_lambda_cons future_status < /dev/null)
  declare fifo=$(bash_lambda_cons future_fifo < /dev/null)

  rm $fifo && mkfifo $fifo

  ("$@" > $output; echo $? > $exit_code; echo > $fifo; rm $fifo) >& /dev/null &
  printf $"%s\n%s\n%s" $output $exit_code $fifo | bash_lambda_cons future; }

bash_lambda_future_complete() {
  # Exits with 0 if the future is finished, 1 if still running. If 0, a
  # future_get call will block only on IO, but not on job completion.
  [[ -s "$(bash_lambda_nth 1 "$1")" ]]; }

bash_lambda_future_get() {
  # This function blocks on the future's process if it is still running, and
  # its stdout and exit code are proxied.

  bash_lambda_future_complete "$1" ||
    cat "$(bash_lambda_nth 2 "$1")" >& /dev/null
  cat "$(bash_lambda_nth 0 "$1")"
  return "$(< "$(bash_lambda_nth 1 "$1")")"; }

bash_lambda_future_transpose() {
  # transpose list of futures = future of list
  declare filename=$1
  bash_lambda_future $(bash_lambda_partial \
    bash_lambda_map bash_lambda_future_get $filename); }

bash_lambda_defmulti complete > /dev/null
bash_lambda_defmulti get      > /dev/null

# Bash-lambda function exporting and GC hooks

# Export the bash_lambda library into the current heap
bash_lambda_init() {
  declare -f | grep '^bash_lambda' | sed 's/ .*//' |
  (declare fn; while read fn; do
    bash_lambda_extern $fn > /dev/null
    if [[ -z "$BASH_LAMBDA_NO_ALIASES" ]]; then
      bash_lambda_def ${fn##bash_lambda_} $fn; fi; done); }

bash_lambda_init

# Run a GC, if necessary, after each command
export PROMPT_COMMAND="$PROMPT_COMMAND; bash_lambda_auto_gc"

