#!/bin/bash
# Bash-lambda

# Source this file to create a function allocation space and enable first-class
# functions in the shell. The heap will be deleted automatically when the shell
# exits. See https://github.com/spencertipping/bash-lambda for documentation.

# Bash-lambda disk-based heap

# We need 128 bits of entropy for the heap directory name. This gives us
# guarantees about the soundness of conservative garbage collection ... for the
# rest of the story, see src/gc.

# 128 bits total / 15 bits per random number = 9 numbers
bash_lambda_genkey() { declare i
                       for (( i = 0; i < 9; i += 1 )); do
                         printf '%04x' $RANDOM; done; }

# Allow the user to override the heap location if they want to. However, this
# may compromise the effectiveness of conservative GC.
export BASH_LAMBDA_KEY=$(bash_lambda_genkey)
export BASH_LAMBDA_HEAP=${BASH_LAMBDA_HEAP:-/tmp/blheap-$$-$BASH_LAMBDA_KEY}

# Set this to 0 to disable asynchronous garbage collection.
export BASH_LAMBDA_GC_SECONDS=30

mkdir -p $BASH_LAMBDA_HEAP || return 1
ln -s $BASH_LAMBDA_HEAP $BASH_LAMBDA_HEAP/.weak-references
date +%s > $BASH_LAMBDA_HEAP/.last-gc
bash_lambda_nuke_heap() { rm -rf $BASH_LAMBDA_HEAP; }
trap bash_lambda_nuke_heap EXIT
export PATH="$PATH:$BASH_LAMBDA_HEAP"

# Heap allocation
bash_lambda_gensym() { echo "${1:-gensym}_$$_$(date +%s_%N)"; }

bash_lambda_cons() {
  declare file=$BASH_LAMBDA_HEAP/$(bash_lambda_gensym $1)
  if [[ $1 == '-n' ]]; then file=$BASH_LAMBDA_HEAP/$2; fi

  # Trigger a concurrent GC if it's been more than some number of seconds since
  # the last one. This turns out to be one of the few constant-time ways we can
  # do this safely.
  if (( $BASH_LAMBDA_GC_SECONDS &&
        $(date +%s) - $(<$BASH_LAMBDA_HEAP/.last-gc) >
          $BASH_LAMBDA_GC_SECONDS )); then
    date +%s > $BASH_LAMBDA_HEAP/.last-gc
    bash_lambda_gc >> $BASH_LAMBDA_HEAP/.gc-log &
  fi

  # If garbage collection is in-progress, mark the object to prevent it from
  # being collected this time around. We don't mark it as having been visited,
  # however; doing that would cause anything it makes live to be collected
  # erroneously.
  touch $BASH_LAMBDA_HEAP/.gc-marked-set/${file##*/} >& /dev/null

  cat - > $file &&      # Take everything from stdin
    chmod u+x $file &&  # All conses are executable
    echo $file; }

# Bash-lambda concurrent mark-sweep garbage collector

mkdir -p $BASH_LAMBDA_HEAP/.gc-permanent

# This function can be run asynchronously: bash_lambda_run_gc &. It knows which
# heap to run on, and it echoes information about the number of objects and
# bytes reclaimed.
bash_lambda_gc() {
  # Try to acquire the GC lock. If we can't, another GC is probably running; so
  # we exit immediately since GC is (ideally) idempotent.
  mkdir $BASH_LAMBDA_HEAP/.gc-visited-set || return 1
  mkdir -p $BASH_LAMBDA_HEAP/.gc-marked-set

  # We have the lock. At this point the heap allocator will mark any new
  # objects that are created, so we can use the root set that exists right now
  # and start marking objects referenced by that root set.

  # Before we do anything, however, we need to wait for a few seconds to make
  # sure the system has a chance to stabilize. In particular, here are the
  # known cases where an object can be prematurely collected:
  #
  # 1. Immediately after entering a command. At this point the command-line
  #    will have been parsed and conses will be allocated, but the parent
  #    process ID may not yet exist. This will prevent us from detecting
  #    objects in the process table roots.
  # 2. When it appears in a delayed command. For example:
  #    $ sleep 5; map $(fn ...) $my_list
  #    The $(fn) form is evaluated immediately but won't be visible in the root
  #    set for another five seconds.
  #
  # The safest way to work around these problems is to stash values into
  # variables. These will always be detected by the GC. You can also put them
  # into environment variables visible to other processes, at which point the
  # other processes will hold weak references to them.

  sleep 10

  (declare; ps ax) | bash_lambda_gc_refs |
  (declare ref; while read ref; do bash_lambda_gc_visit "$ref"; done)

  # Now nuke anything that isn't either marked or permanent.
  ls -d $BASH_LAMBDA_HEAP/* | (
    declare ref reclaimed=() reclaimed_size=0
    while read ref; do
      if [[ ! -e "$BASH_LAMBDA_HEAP/.gc-marked-set/${ref##*/}" &&
            ! -e "$BASH_LAMBDA_HEAP/.gc-permanent/${ref##*/}" ]]; then
        reclaimed[${#reclaimed[@]}]="$ref"
        reclaimed_size=$((reclaimed_size + $(du -sb "$ref" | cut -f 1)))
        rm -rf "$ref"; fi; done
    echo "${#reclaimed[@]} $reclaimed_size")

  # We are now done. Remove the marked-set directory and echo some stats about
  # the stuff we collected.
  rm -rf $BASH_LAMBDA_HEAP/.gc-{marked,visited}-set; }

bash_lambda_heap_stats() {
  printf '%-20s %s\n%-20s %d\n%-20s %d\n' \
    'heap size:' $(du -sh $BASH_LAMBDA_HEAP | cut -f 1) \
    'objects:'   $(ls $BASH_LAMBDA_HEAP | wc -l) \
    'permanent:' $(ls $BASH_LAMBDA_HEAP/.gc-permanent | wc -l); }

bash_lambda_gc_pin() {
  # Pins an object so that it will never be collected.
  touch $BASH_LAMBDA_HEAP/.gc-permanent/${1##*/};
  echo "$1"; }

bash_lambda_gc_visit() {
  # The ref in question must be an object that exists in the heap. We expect it
  # to be a full pathname, though the object itself should be a direct child of
  # the heap directory.
  declare child ref="$1" ref_name="${ref#$BASH_LAMBDA_HEAP/}"

  # No need to mark an object in a subdirectory. It isn't a direct child of the
  # heap, so its storage is already being managed by the directory it belongs
  # to.
  if [[ ! ("$ref_name" =~ /) ]]; then
    # Have we already visited this object? If so, no need to revisit it.
    [[ -e $BASH_LAMBDA_HEAP/.gc-visited-set/$ref_name ]] && return 0

    # Otherwise, mark the object and everything it points to.
    touch $BASH_LAMBDA_HEAP/.gc-{marked,visited}-set/$ref_name; fi

  if [[ -d "$ref" ]]; then
    for child in $ref/*; do bash_lambda_gc_visit "$child"; done
  else
    # Search for GC refs in the child.
    bash_lambda_gc_refs < "$ref" | (declare child; while read child; do
      bash_lambda_gc_visit "$child"; done); fi; }

bash_lambda_gc_refs() {
  # Locate occurrences of the heap directory. This name contains 128 bits of
  # pseudorandom entropy, so we are unlikely to see it spuriously referenced.
  # If we observe a path that exists, then we consider that to be a reference
  # for GC purposes.

  # This function is a total hack.
  egrep -o "$BASH_LAMBDA_HEAP/[^ /\)\}\"']+"; }

# Bash-lambda weak references

# A weak reference is a path that resolves the same way as a regular path, but
# that isn't followed by the garbage collector. src/heap sets up a symlink for
# this purpose.
bash_lambda_weak_ref() {
  echo "$BASH_LAMBDA_HEAP/.weak-references/${1##$BASH_LAMBDA_HEAP/}"; }

# Bash-lambda function and closure allocation

bash_lambda_fn_body() {
  echo '#!/bin/bash'
  declare i
  for (( i = 1; i <= $#; i += 1 )); do
    if (( $i < $# )); then echo "declare -r ${!i}=\$$i"
    else                   echo "${!i}"; fi
  done; }

bash_lambda_fn() {
  # Yup, we're allocating closures by writing to files and returning their
  # names to the callers. This gives you controllable persistence, heap
  # allocation, and the ability to reference the same closures across multiple
  # processes.
  bash_lambda_fn_body "$@" | bash_lambda_cons fn; }

bash_lambda_cons_fn() {
  # Same as bash_lambda_fn, but body is specified from stdin. Useful for
  # multiline functions when used with heredocs.
  (bash_lambda_fn_body "$@" ''; cat -) | bash_lambda_cons fn; }

bash_lambda_defn() { declare name=$1; shift
                     bash_lambda_fn_body "$@" | bash_lambda_cons -n $name; }

# Exports functions into named files in the heap. This allows them to reference
# each other from inside heap-allocated closures. Any exported functions are
# pinned so that they will never be garbage-collected.
bash_lambda_extern() {
  bash_lambda_gc_pin $( (echo "$1_main() {"
                         declare -f "$1" | grep '^  '
                         echo "}"
                         echo "$1_main \"\$@\"") | bash_lambda_cons -n $1); }

bash_lambda_def() { rm -f $BASH_LAMBDA_HEAP/$1
                    ln -s $2 $(bash_lambda_gc_pin $BASH_LAMBDA_HEAP/$1); }

# Bash-lambda functional programming constructs

# $(comp $f $g $h) x = f $(g $(h x))
# $(partial $f x) y  = f x y
bash_lambda_comp() {
  declare i body
  for (( i = $#; i >= 1; i -= 1 )); do
    if (( $i == $# )); then body="\$(${!i} \"\$@\")";
    else                    body="\$(${!i} $body)"; fi
  done
  bash_lambda_fn "echo $body"; }

bash_lambda_partial() {
  bash_lambda_fn "exec $* \"\$@\""; }

# Bash-lambda list programming constructs

bash_lambda_list() { declare x
                     for x; do echo "$x"; done | bash_lambda_cons list; }
bash_lambda_take() { cat ${2:--} | head -n$1; }
bash_lambda_drop() { cat ${2:--} | (declare i
                                    for (( i = 0; i < $1; i += 1 )); do
                                      read x; done; cat -); }

# Here, 'map' works as both map and mapcat since cons and append are the same
# operation. This arises due to the associativity of cons.
bash_lambda_map()    { cat ${2:--} | (declare x
                                      while read x; do $1 "$x"; done); }
bash_lambda_reduce() { declare f="$1" x="$2"
                       cat ${3:--} | (declare y
                                      while read y; do x="$($f "$x" "$y")"; done
                                      echo "$x"); }
bash_lambda_filter() { cat ${2:--} | (declare x
                                      while read x; do
                                        $1 "$x" > /dev/null && echo $x; done); }

# List generators
bash_lambda_iterate() { declare x="$2"
                        echo "$x"; while x="$($1 $x)"; do echo "$x"; done; }

bash_lambda_repeatedly() { declare i f="$1" n="$2"
                           for (( i = 0; i != ${n:--1}; i += 1 )); do
                             $f; done; }

# Bash-lambda function exporting

# Export the bash_lambda library into the current heap
bash_lambda_init() {
  declare fn
  declare -f | grep '^bash_lambda' | sed 's/ .*//' | while read fn; do
    bash_lambda_extern $fn > /dev/null
    if [[ -z "$BASH_LAMBDA_NO_ALIASES" ]]; then
      bash_lambda_def ${fn##bash_lambda_} $fn; fi; done; }

bash_lambda_init

